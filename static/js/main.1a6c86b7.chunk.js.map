{"version":3,"sources":["components/Song.js","components/Lyrics.js","components/Player.js","App.js","serviceWorker.js","index.js"],"names":["Song","props","Object","entries","currentlyPlayingSong","song","length","item","name","artists","map","artist","id","key","src","album","images","url","alt","statusCode","Lyrics","useState","lyrics","setLyrics","fetching","setFetching","songInformation","useEffect","options","apiKey","title","optimizeQuery","getLyrics","then","catch","err","Spinner","animation","role","className","Player","setCurrentlyPlayingSong","callback","delay","savedCallback","useRef","current","setInterval","clearInterval","useInterval","accessToken","getCurrentlyPlayingSong","is_playing","token","console","log","config","headers","Authorization","axios","get","response","status","data","error","ProgressBar","now","progress_ms","max","duration_ms","Button","onClick","$","ajax","type","beforeSend","xhr","setRequestHeader","success","disabled","queryString","require","cookies","Cookies","scopes","App","setAccessToken","parsedAccessToken","parse","window","location","hash","expiresIn","cookie_token","undefined","d","Date","setTime","getTime","set","path","expires","href","join","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.1a6c86b7.chunk.js","sourcesContent":["import React, {Fragment} from 'react';\r\n\r\nfunction Song(props) {\r\n    return (\r\n        <div>\r\n            {Object.entries(props.currentlyPlayingSong.song).length ?\r\n                <Fragment>\r\n                    <p>Song: {props.currentlyPlayingSong.song.item.name}</p>\r\n                    <p>Artist: {props.currentlyPlayingSong.song.item.artists.map((artist, id = 0) => {\r\n                        if (id === props.currentlyPlayingSong.song.item.artists.length - 1) {\r\n                            return (<span key={id + 1}>{artist.name}</span>)\r\n                        } else {\r\n                            return (<span key={id + 1}>{artist.name}, </span>)\r\n                        }\r\n                    })\r\n                    }\r\n                    </p>\r\n                    <img src={props.currentlyPlayingSong.song.item.album.images[1].url} alt=\"Album Cover\"/>\r\n                </Fragment> : props.currentlyPlayingSong.statusCode === 204 ? <p>No song is currently playing!</p> :\r\n                    <p>Ups! Something went wrong!</p>}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Song;","import React, {useEffect, useState} from 'react';\r\nimport Spinner from \"react-bootstrap/Spinner\";\r\n\r\nimport {getLyrics} from 'genius-lyrics-api';\r\n\r\nfunction Lyrics(props) {\r\n    const [lyrics, setLyrics] = useState('');\r\n    const [fetching, setFetching] = useState(true);\r\n\r\n    const song = props.songInformation.song;\r\n    const artist = props.songInformation.artist[0].name;\r\n\r\n    useEffect(() => {\r\n        const options = {\r\n            apiKey: 'LrIeYTi3GkOFwXbrJE7M7dlIxji1W8UVGevPDw3YOW6vQiyVHi0K9aMvUnssmu5Z',  // genius developer access token\r\n            title: song,\r\n            artist: artist,\r\n            optimizeQuery: true\r\n        };\r\n\r\n        setFetching(true);\r\n        setLyrics('');\r\n\r\n        getLyrics(options).then(lyrics => {\r\n            setLyrics(lyrics);\r\n            setFetching(false);\r\n        }).catch(err => {\r\n            setFetching(false);\r\n            setLyrics('No lyrics found, sorry!');\r\n        })\r\n\r\n    }, [artist, song]);\r\n\r\n\r\n    return (\r\n        <div>\r\n            {fetching ?\r\n                <Spinner animation=\"border\" role=\"status\">\r\n                    <span className=\"sr-only\">Loading...</span>\r\n                </Spinner> : <p></p>}\r\n            {lyrics ? <div className=\"lyrics\">{lyrics}</div> : <p>Fetching lyrics</p>}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Lyrics;\r\n","import React, {useEffect, useRef, useState} from 'react';\r\nimport $ from 'jquery';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport axios from 'axios';\r\nimport Button from \"react-bootstrap/Button\";\r\nimport Song from \"./Song\";\r\nimport ProgressBar from \"react-bootstrap/ProgressBar\";\r\nimport Lyrics from \"./Lyrics\";\r\n\r\n// Endpoints\r\nconst StartResumePlaybackEndpoint = \"https://api.spotify.com/v1/me/player/play\";\r\nconst PausePlaybackEndpoint = \"https://api.spotify.com/v1/me/player/pause\";\r\nconst currentlyPlayingEndpoint = \"https://api.spotify.com/v1/me/player\";\r\n// const recentlyPlayedEndpoint = \"https://api.spotify.com/v1/me/player/recently-played\";\r\nconst skipNextSongEndpoint = \"https://api.spotify.com/v1/me/player/next\";\r\nconst skipPrevSongEndpoint = \"https://api.spotify.com/v1/me/player/previous\";\r\n\r\nfunction Player(props) {\r\n    const [currentlyPlayingSong, setCurrentlyPlayingSong] = useState({\r\n        song: {},\r\n        statusCode: \"\",\r\n    });\r\n\r\n    useInterval(() => {\r\n        if (props.accessToken) {\r\n            getCurrentlyPlayingSong(props.accessToken);\r\n        }\r\n    }, currentlyPlayingSong.song.is_playing ? 1000 : 5000);\r\n\r\n    // Render the song when we obtain the access token\r\n    useEffect(() => {\r\n        if (props.accessToken) {\r\n            getCurrentlyPlayingSong(props.accessToken);\r\n        }\r\n\r\n\r\n    }, [props.accessToken]);\r\n\r\n    function playPauseCurrentTrack(token) {\r\n        setCurrentlyPlayingSong({\r\n            song: {\r\n                ...currentlyPlayingSong.song,\r\n                is_playing: !currentlyPlayingSong.song.is_playing\r\n            }\r\n        });\r\n        $.ajax({\r\n            url: currentlyPlayingSong.song.is_playing ? PausePlaybackEndpoint : StartResumePlaybackEndpoint,\r\n            type: \"PUT\",\r\n            beforeSend: (xhr) => {\r\n                xhr.setRequestHeader(\"Authorization\", `Bearer ${token}`);\r\n            },\r\n            success: (data) => {\r\n                console.log(data);\r\n            },\r\n            error: (error) => {\r\n                console.log(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    const skipNextSong = (token) => {\r\n        console.log(\"Skipping song\");\r\n        $.ajax({\r\n            url: skipNextSongEndpoint,\r\n            type: \"POST\",\r\n            beforeSend: (xhr) => {\r\n                xhr.setRequestHeader(\"Authorization\", `Bearer ${token}`);\r\n            },\r\n            success: (data) => {\r\n                console.log(data);\r\n            },\r\n            error: (error) => {\r\n                console.log(error);\r\n            }\r\n        });\r\n    };\r\n\r\n    const skipPrevSong = (token) => {\r\n        console.log(\"Skipping song\");\r\n        $.ajax({\r\n            url: skipPrevSongEndpoint,\r\n            type: \"POST\",\r\n            beforeSend: (xhr) => {\r\n                xhr.setRequestHeader(\"Authorization\", `Bearer ${token}`);\r\n            },\r\n            success: (data) => {\r\n                console.log(data);\r\n            },\r\n            error: (error) => {\r\n                console.log(error);\r\n            }\r\n        });\r\n    };\r\n\r\n    const getCurrentlyPlayingSong = (token) => {\r\n        console.log(\"Currently playing:\");\r\n        const config = {\r\n            headers: {Authorization: `Bearer ${token}`}\r\n        };\r\n\r\n        axios.get(\r\n            currentlyPlayingEndpoint,\r\n            config\r\n        ).then(response => {\r\n            if (response.status === 200) {\r\n                setCurrentlyPlayingSong({\r\n                    song: response.data,\r\n                    statusCode: response.status\r\n                });\r\n            } else if (response.status !== 200) {\r\n                // getRecentlyPlayedSong(token);\r\n                console.log(response);\r\n            }\r\n        }).catch(error => {\r\n            console.log(error);\r\n        });\r\n    };\r\n\r\n    // const getRecentlyPlayedSong = (token) => {\r\n    //     console.log(\"Recently played:\");\r\n    //     const config = {\r\n    //         headers: {Authorization: `Bearer ${token}`}\r\n    //     };\r\n    //     axios.get(\r\n    //         recentlyPlayedEndpoint,\r\n    //         config\r\n    //     ).then(response => {\r\n    //         console.log(response);\r\n    //         if (response.status === 200) {\r\n    //             setCurrentlyPlayingSong({\r\n    //                 song: response.data.items[0],\r\n    //                 statusCode: response.status\r\n    //             });\r\n    //         } else if (response.status !== 200) {\r\n    //             setCurrentlyPlayingSong({\r\n    //                 song: '',\r\n    //                 statusCode: response.status\r\n    //             });\r\n    //         }\r\n    //     }).catch(error => {\r\n    //         console.log(error);\r\n    //     });\r\n    // };\r\n\r\n    return (\r\n        <div>\r\n            {props.accessToken && Object.entries(currentlyPlayingSong.song).length ?\r\n                <div className=\"row align-items-center\">\r\n                    <div className=\"col-sm vw-100\">\r\n                        <Song currentlyPlayingSong={currentlyPlayingSong}/>\r\n                        <ProgressBar className=\"progressBar\" now={currentlyPlayingSong.song.progress_ms}\r\n                                     max={currentlyPlayingSong.song.item.duration_ms}/>\r\n\r\n                        <Button className=\"control-button\" onClick={() => {\r\n                            skipPrevSong(props.accessToken)\r\n                        }}>\r\n                            Previous\r\n                        </Button>\r\n\r\n                        <Button className=\"control-button\"\r\n                                onClick={() => playPauseCurrentTrack(props.accessToken)}>{currentlyPlayingSong.song.is_playing ?\r\n                            <span>Stop</span> : <span>Play</span>}\r\n                        </Button>\r\n\r\n                        <Button className=\"control-button\" onClick={() => {\r\n                            skipNextSong(props.accessToken)\r\n                        }}>\r\n                            Next\r\n                        </Button>\r\n                    </div>\r\n\r\n                    <div className=\"col-sm overflow-auto vw-100 vh-100\">\r\n                        <Lyrics songInformation={\r\n                            {\r\n                                song: currentlyPlayingSong.song.item.name,\r\n                                artist: currentlyPlayingSong.song.item.artists\r\n                            }\r\n                        }/>\r\n                    </div>\r\n                </div>\r\n                :\r\n                <Button disabled={true}>Play</Button>}\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction useInterval(callback, delay) {\r\n    const savedCallback = useRef();\r\n\r\n    // Remember the latest function.\r\n    useEffect(() => {\r\n        savedCallback.current = callback;\r\n    }, [callback]);\r\n\r\n    // Set up the interval.\r\n    useEffect(() => {\r\n        function tick() {\r\n            savedCallback.current();\r\n        }\r\n\r\n        if (delay !== null) {\r\n            let id = setInterval(tick, delay);\r\n            return () => clearInterval(id);\r\n        }\r\n    }, [delay]);\r\n}\r\n\r\nexport default Player;\r\n","import React, {useEffect, useState} from 'react';\r\nimport './App.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport Cookies from 'universal-cookie';\r\nimport Player from \"./components/Player\";\r\n\r\nconst queryString = require('querystring');\r\nconst cookies = new Cookies();\r\n\r\nconst authEndpoint = \"https://accounts.spotify.com/authorize\";\r\n\r\n\r\n// Secrets\r\nconst clientId = \"a6edcec27c8b4ca5b8f5f91287a63ee8\";\r\nconst redirectUri = \"http://robertma96.github.io/react-spotify-lyrics\"; // \"http://localhost:3000\"\r\nconst scopes = [\r\n    \"user-read-playback-state\",\r\n    \"user-read-currently-playing\",\r\n    \"user-read-private\",\r\n    \"user-modify-playback-state\",\r\n    \"user-read-recently-played\"\r\n];\r\n\r\n// const cookieAccessToken = cookies.get('access_token');\r\n\r\nfunction App() {\r\n    const [accessToken, setAccessToken] = useState('');\r\n\r\n    useEffect(() => {\r\n        const parsedAccessToken = queryString.parse(window.location.hash)['#access_token'];\r\n        const expiresIn = queryString.parse(window.location.hash)['expires_in'];\r\n        const cookie_token = cookies.get('access_token');\r\n\r\n        if (cookie_token !== undefined) {\r\n            console.log('got it from cookies');\r\n            setAccessToken(cookie_token);\r\n        }\r\n        else if (parsedAccessToken) {\r\n            setAccessToken(parsedAccessToken);\r\n            // Calculating the expire time for the cookie\r\n            let d = new Date();\r\n            d.setTime(d.getTime() + (expiresIn / 60 * 60 * 1000));\r\n            cookies.set('access_token', parsedAccessToken, {path: '/', expires: d});\r\n        }\r\n\r\n    }, [accessToken]);\r\n\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <header className=\"App-header container-fluid\">\r\n                {accessToken ? <Player accessToken={accessToken}/> :\r\n                    <a href={`${authEndpoint}?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scopes.join(\"%20\")}&response_type=token&show_dialog=true`}>Login\r\n                        to Spotify</a>}\r\n            </header>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}